{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar _Object$getOwnPropertyNames = _interopDefault(require('babel-runtime/core-js/object/get-own-property-names'));\nvar _objectWithoutProperties = _interopDefault(require('babel-runtime/helpers/objectWithoutProperties'));\nvar _extends = _interopDefault(require('babel-runtime/helpers/extends'));\nvar messageformatParser = require('messageformat-parser');\nvar _slicedToArray = _interopDefault(require('babel-runtime/helpers/slicedToArray'));\nvar plurals = _interopDefault(require('make-plural/umd/plurals'));\nvar _Object$keys = _interopDefault(require('babel-runtime/core-js/object/keys'));\nvar _typeof = _interopDefault(require('babel-runtime/helpers/typeof'));\nvar _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));\nvar _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));\nvar isString = function isString(s) {\n  return typeof s === \"string\";\n};\nvar isFunction = function isFunction(f) {\n  return typeof f === \"function\";\n};\nfunction isEmpty(obj) {\n  // null and undefined are \"empty\"\n  if (obj === null || obj === undefined) return true;\n  if (obj.length > 0) return false;\n  if (obj.length === 0) return true;\n  return !_Object$getOwnPropertyNames(obj).length;\n}\nfunction date(locales) {\n  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formatter = new Intl.DateTimeFormat(locales, format);\n  return function (value) {\n    if (isString(value)) value = new Date(value);\n    return formatter.format(value);\n  };\n}\nfunction number(locales) {\n  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formatter = new Intl.NumberFormat(locales, format);\n  return function (value) {\n    return formatter.format(value);\n  };\n}\nvar defaultFormats = function defaultFormats(language, locales) {\n  var languageData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var formats = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  locales = locales || language;\n  var plurals$$1 = languageData.plurals;\n  var style = function style(format) {\n    return isString(format) ? formats[format] || {\n      style: format\n    } : format;\n  };\n  var replaceOctothorpe = function replaceOctothorpe(value, message) {\n    return function (ctx) {\n      var msg = isFunction(message) ? message(ctx) : message;\n      var norm = Array.isArray(msg) ? msg : [msg];\n      var formatter = new Intl.NumberFormat(locales);\n      var valueStr = formatter.format(value);\n      return norm.map(function (m) {\n        return isString(m) ? m.replace(\"#\", valueStr) : m;\n      });\n    };\n  };\n  return {\n    plural: function plural(value, _ref) {\n      var _ref$offset = _ref.offset,\n        offset = _ref$offset === undefined ? 0 : _ref$offset,\n        rules = _objectWithoutProperties(_ref, [\"offset\"]);\n      var message = rules[value] || rules[plurals$$1(value - offset)];\n      return replaceOctothorpe(value - offset, message);\n    },\n    selectordinal: function selectordinal(value, _ref2) {\n      var _ref2$offset = _ref2.offset,\n        offset = _ref2$offset === undefined ? 0 : _ref2$offset,\n        rules = _objectWithoutProperties(_ref2, [\"offset\"]);\n      var message = rules[value] || rules[plurals$$1(value - offset, true)];\n      return replaceOctothorpe(value - offset, message);\n    },\n    select: function select(value, rules) {\n      return rules[value] || rules.other;\n    },\n    number: function number$$1(value, format) {\n      return number(locales, style(format))(value);\n    },\n    date: function date$$1(value, format) {\n      return date(locales, style(format))(value);\n    },\n    undefined: function undefined(value) {\n      return value;\n    }\n  };\n};\n\n// Params -> CTX\n/**\n * Creates a context object, which formats ICU MessageFormat arguments based on\n * argument type.\n *\n * @param language     - Language of message\n * @param locales      - Locales to be used when formatting the numbers or dates\n * @param values       - Parameters for variable interpolation\n * @param languageData - Language data (e.g: plurals)\n * @param formats - Custom format styles\n * @returns {function(string, string, any)}\n */\nfunction context(_ref3) {\n  var language = _ref3.language,\n    locales = _ref3.locales,\n    values = _ref3.values,\n    formats = _ref3.formats,\n    languageData = _ref3.languageData;\n  var formatters = defaultFormats(language, locales, languageData, formats);\n  var ctx = function ctx(name, type, format) {\n    var value = values[name];\n    var formatted = formatters[type](value, format);\n    var message = isFunction(formatted) ? formatted(ctx) : formatted;\n    return Array.isArray(message) ? message.join(\"\") : message;\n  };\n  return ctx;\n}\nfunction interpolate(translation, language, locales, languageData) {\n  return function (values) {\n    var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var message = translation(context({\n      language: language,\n      locales: locales,\n      languageData: languageData,\n      formats: formats,\n      values: values\n    }));\n    return Array.isArray(message) ? message.join(\"\").trim() : message;\n  };\n}\nvar flatten = function flatten(arrays) {\n  return [].concat.apply([], arrays);\n};\nvar zip = function zip(a, b) {\n  return a.map(function (item, index) {\n    return [item, b[index]];\n  });\n};\nvar t = function t(strings) {\n  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  return flatten(zip(strings, values)).join(\"\");\n};\nvar _plural = function _plural(type) {\n  return function (i18n) {\n    return function (_ref) {\n      var value = _ref.value,\n        _ref$offset = _ref.offset,\n        offset = _ref$offset === undefined ? 0 : _ref$offset,\n        locales = _ref.locales,\n        format = _ref.format,\n        other = _ref.other,\n        pluralForms = _objectWithoutProperties(_ref, [\"value\", \"offset\", \"locales\", \"format\", \"other\"]);\n      if (locales === undefined) locales = i18n.locales || i18n.language;\n      var diff = value - offset;\n      var diffAsString = number(locales, format)(diff);\n      var translation = pluralForms[value.toString()] ||\n      // exact match\n      pluralForms[i18n.pluralForm(diff, type)] ||\n      // plural form\n      other; // fallback\n      return translation.replace(\"#\", diffAsString);\n    };\n  };\n};\nvar plural = _plural(\"cardinal\");\nvar selectOrdinal = _plural(\"ordinal\");\nfunction select(_ref2) {\n  var value = _ref2.value,\n    other = _ref2.other,\n    selectForms = _objectWithoutProperties(_ref2, [\"value\", \"other\"]);\n  return selectForms[value] || other;\n}\n\n// [Tokens] -> (CTX -> String)\nfunction processTokens(tokens) {\n  var octothorpe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!tokens.filter(function (token) {\n    return !isString(token);\n  }).length) {\n    return tokens.join(\"\");\n  }\n  return function (ctx) {\n    return tokens.map(function (token) {\n      if (isString(token)) {\n        return token;\n\n        // # in plural case\n      } else if (token.type === \"octothorpe\") {\n        var name = octothorpe.name,\n          _octothorpe$offset = octothorpe.offset,\n          _offset = _octothorpe$offset === undefined ? 0 : _octothorpe$offset;\n        return ctx(name) - _offset;\n\n        // simple argument\n      } else if (token.type === \"argument\") {\n        return ctx(token.arg);\n\n        // argument with custom format (date, number)\n      } else if (token.type === \"function\") {\n        return ctx(token.arg, token.key, token.params[0]);\n      }\n      var offset = token.offset ? parseInt(token.offset) : undefined;\n\n      // complex argument with cases\n      var formatProps = {};\n      token.cases.forEach(function (item) {\n        formatProps[item.key] = processTokens(item.tokens, {\n          name: token.arg,\n          offset: offset\n        });\n      });\n      return ctx(token.arg, token.type, _extends({\n        offset: offset\n      }, formatProps));\n    });\n  };\n}\n\n// Message -> (Params -> String)\nfunction compile(message) {\n  try {\n    return processTokens(messageformatParser.parse(message));\n  } catch (e) {\n    console.error(\"Message cannot be parsed due to syntax errors: \" + message);\n    return message;\n  }\n}\nvar loadLanguageData = function loadLanguageData(locale) {\n  if (!locale) {\n    return;\n  }\n  var _locale$split = locale.split(/[_-]/),\n    _locale$split2 = _slicedToArray(_locale$split, 1),\n    language = _locale$split2[0];\n  return {\n    plurals: plurals[language]\n  };\n};\nvar dev = /*#__PURE__*/Object.freeze({\n  compile: compile,\n  loadLanguageData: loadLanguageData\n});\nfunction getLanguageData(catalog) {\n  return (catalog || {}).languageData || {};\n}\nfunction getMessages(catalog) {\n  return (catalog || {}).messages || {};\n}\nvar I18n = function () {\n  function I18n() {\n    _classCallCheck(this, I18n);\n\n    // Messages and languageData are merged on load,\n    // so we must initialize it manually\n    this._activeMessages = {};\n    this._catalogs = {};\n    {\n      this.t = t;\n      this.select = select;\n      this.plural = plural(this);\n      this.selectOrdinal = selectOrdinal(this);\n    }\n  }\n\n  // Messages/language data in active language.\n  // This is optimization, so we don't perform object lookup\n  // _catalogs[language] for each translation.\n\n  // Message catalogs\n\n  _createClass(I18n, [{\n    key: \"_cacheActiveLanguage\",\n    value: function _cacheActiveLanguage() {\n      var activeCatalog = this._catalogs[this.language];\n      var languageData = getLanguageData(activeCatalog);\n      {\n        // Allow overriding data in development, useful for testing\n        if (isEmpty(languageData) && this._dev && isFunction(this._dev.loadLanguageData)) {\n          languageData = this._dev.loadLanguageData(this.language);\n        }\n      }\n      this._activeMessages = getMessages(activeCatalog);\n      this._activeLanguageData = languageData;\n    }\n  }, {\n    key: \"load\",\n    value: function load(catalogs) {\n      var _this = this;\n      if ((typeof catalogs === \"undefined\" ? \"undefined\" : _typeof(catalogs)) !== \"object\") return;\n\n      // deeply merge Catalogs\n      _Object$keys(_extends({}, this._catalogs, catalogs)).forEach(function (language) {\n        var compiledMessages = getMessages(catalogs[language]);\n        {\n          if (_this._dev && isFunction(_this._dev.compile)) {\n            compiledMessages = _Object$keys(compiledMessages).reduce(function (dict, id) {\n              var msg = compiledMessages[id];\n              dict[id] = isString(msg) ? _this._dev.compile(msg) : msg;\n              return dict;\n            }, {});\n          }\n        }\n        _this._catalogs[language] = {\n          messages: _extends({}, getMessages(_this._catalogs[language]), compiledMessages),\n          languageData: _extends({}, getLanguageData(_this._catalogs[language]), getLanguageData(catalogs[language]))\n        };\n      });\n      this._cacheActiveLanguage();\n    }\n  }, {\n    key: \"activate\",\n    value: function activate(language, locales) {\n      if (!language) return;\n      {\n        if (this.availableLanguages.indexOf(language) === -1) {\n          console.warn(\"Message catalog for locale \\\"\" + language + \"\\\" not loaded.\");\n        }\n      }\n      this._language = language;\n      this._locales = locales;\n      this._cacheActiveLanguage();\n    }\n  }, {\n    key: \"use\",\n    value: function use(language, locales) {\n      return setupI18n({\n        language: language,\n        locales: locales,\n        catalogs: this._catalogs,\n        development: this._dev\n      });\n    }\n\n    // default translate method\n  }, {\n    key: \"_\",\n    value: function _(id) {\n      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        defaults = _ref.defaults,\n        _ref$formats = _ref.formats,\n        formats = _ref$formats === undefined ? {} : _ref$formats;\n\n      // Expand message descriptor\n      if (id && (typeof id === \"undefined\" ? \"undefined\" : _typeof(id)) === \"object\") {\n        values = id.values;\n        defaults = id.defaults;\n        formats = id.formats;\n        id = id.id;\n      }\n      var translation = this.messages[id] || defaults || id;\n\n      // replace missing messages with custom message for debugging\n      var missing = this._missing;\n      if (missing && !this.messages[id]) {\n        translation = isFunction(missing) ? missing(this.language, id) : missing;\n      }\n      {\n        if (isString(translation) && this._dev && isFunction(this._dev.compile)) {\n          translation = this._dev.compile(translation);\n        }\n      }\n      if (!isFunction(translation)) return translation;\n      return interpolate(translation, this.language, this.locales, this.languageData)(values, formats);\n    }\n  }, {\n    key: \"pluralForm\",\n    value: function pluralForm(n) {\n      var pluralType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"cardinal\";\n      if (!this.languageData.plurals) return \"other\";\n      return this.languageData.plurals(n, pluralType === \"ordinal\");\n    }\n  }, {\n    key: \"date\",\n    value: function date$$1(value, format) {\n      return date(this.locales || this.language, format)(value);\n    }\n  }, {\n    key: \"number\",\n    value: function number$$1(value, format) {\n      return number(this.locales || this.language, format)(value);\n    }\n  }, {\n    key: \"availableLanguages\",\n    get: function get() {\n      return _Object$keys(this._catalogs);\n    }\n  }, {\n    key: \"language\",\n    get: function get() {\n      return this._language;\n    }\n  }, {\n    key: \"locales\",\n    get: function get() {\n      return this._locales;\n    }\n  }, {\n    key: \"messages\",\n    get: function get() {\n      return this._activeMessages;\n    }\n  }, {\n    key: \"languageData\",\n    get: function get() {\n      return this._activeLanguageData;\n    }\n  }]);\n  return I18n;\n}();\nfunction setupI18n() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var i18n = new I18n();\n  {\n    i18n._dev = dev;\n  }\n  if (params.catalogs) i18n.load(params.catalogs);\n  if (params.language) i18n.activate(params.language, params.locales);\n  if (params.missing) i18n._missing = params.missing;\n  return i18n;\n}\nvar i18n = setupI18n();\nvar i18nMark = function i18nMark(id) {\n  return id;\n};\nexports.i18nMark = i18nMark;\nexports.i18n = i18n;\nexports.setupI18n = setupI18n;\nexports.date = date;\nexports.number = number;","map":null,"metadata":{},"sourceType":"script"}