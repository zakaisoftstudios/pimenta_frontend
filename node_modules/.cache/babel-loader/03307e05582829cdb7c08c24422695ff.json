{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.propagateErrors = propagateErrors;\nexports.settled = settled;\nexports.collectErrors = collectErrors;\nexports.default = runValidations;\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _synchronousPromise = require(\"synchronous-promise\");\nvar _ValidationError = _interopRequireDefault(require(\"../ValidationError\"));\nvar promise = function promise(sync) {\n  return sync ? _synchronousPromise.SynchronousPromise : Promise;\n};\nvar unwrapError = function unwrapError(errors) {\n  if (errors === void 0) {\n    errors = [];\n  }\n  return errors.inner && errors.inner.length ? errors.inner : [].concat(errors);\n};\nfunction scopeToValue(promises, value, sync) {\n  //console.log('scopeToValue', promises, value)\n  var p = promise(sync).all(promises); //console.log('scopeToValue B', p)\n\n  var b = p.catch(function (err) {\n    if (err.name === 'ValidationError') err.value = value;\n    throw err;\n  }); //console.log('scopeToValue c', b)\n\n  var c = b.then(function () {\n    return value;\n  }); //console.log('scopeToValue d', c)\n\n  return c;\n}\n/**\n * If not failing on the first error, catch the errors\n * and collect them in an array\n */\n\nfunction propagateErrors(endEarly, errors) {\n  return endEarly ? null : function (err) {\n    errors.push(err);\n    return err.value;\n  };\n}\nfunction settled(promises, sync) {\n  var settle = function settle(promise) {\n    return promise.then(function (value) {\n      return {\n        fulfilled: true,\n        value: value\n      };\n    }, function (value) {\n      return {\n        fulfilled: false,\n        value: value\n      };\n    });\n  };\n  return promise(sync).all(promises.map(settle));\n}\nfunction collectErrors(_ref) {\n  var validations = _ref.validations,\n    value = _ref.value,\n    path = _ref.path,\n    sync = _ref.sync,\n    errors = _ref.errors,\n    sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) {\n      var error = _ref2.value;\n\n      // we are only collecting validation errors\n      if (!_ValidationError.default.isError(error)) {\n        throw error;\n      }\n      return arr.concat(error);\n    }, []);\n    if (sort) nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name\n\n    errors = nestedErrors.concat(errors);\n    if (errors.length) throw new _ValidationError.default(errors, value, path);\n    return value;\n  });\n}\nfunction runValidations(_ref3) {\n  var endEarly = _ref3.endEarly,\n    options = (0, _objectWithoutPropertiesLoose2.default)(_ref3, [\"endEarly\"]);\n  if (endEarly) return scopeToValue(options.validations, options.value, options.sync);\n  return collectErrors(options);\n}","map":null,"metadata":{},"sourceType":"script"}