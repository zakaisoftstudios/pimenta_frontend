{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DebounceCache = exports.onlyResolvesLast = exports.debounce = undefined;\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _debouncePromise = require('debounce-promise');\nvar _debouncePromise2 = _interopRequireDefault(_debouncePromise);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// We use DebouncePromise as a dependency as it does a great low-level job\n// The behavior of the lib is to return the same promise for all function calls\nvar debounce = exports.debounce = function debounce(func, wait, options) {\n  return (0, _debouncePromise2.default)(func, wait, options);\n};\n\n// Given a function returning promises, wrap it so that only the promise returned from last call will actually resolve\n// This is useful to ignore former async results and handle concurrency issues\nvar onlyResolvesLast = exports.onlyResolvesLast = function onlyResolvesLast(asyncFunction) {\n  // Inspired from https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html\n  var makeCancelable = function makeCancelable(promise) {\n    var hasCanceled_ = false;\n    var wrappedPromise = new Promise(function (resolve, reject) {\n      promise.then(function (val) {\n        return hasCanceled_ ? undefined : resolve(val);\n      }, function (error) {\n        return hasCanceled_ ? undefined : reject(error);\n      });\n    });\n    return {\n      promise: wrappedPromise,\n      cancel: function cancel() {\n        hasCanceled_ = true;\n      }\n    };\n  };\n  var cancelPrevious = void 0;\n  return function () {\n    cancelPrevious && cancelPrevious();\n    var _makeCancelable = makeCancelable(asyncFunction.apply(undefined, arguments)),\n      promise = _makeCancelable.promise,\n      cancel = _makeCancelable.cancel;\n    cancelPrevious = cancel;\n    return promise;\n  };\n};\n\n// We create a debouncing function cache, because when wrapping the original function,\n// we may actually want to route the function call to different debounced functions depending function paameters\n\nvar DebounceCache = exports.DebounceCache = function DebounceCache() {\n  var _this = this;\n  _classCallCheck(this, DebounceCache);\n  this.getDebouncedFunction = function (func, wait, options, args) {\n    var keyOptions = options.key,\n      onlyResolvesLastOption = options.onlyResolvesLast,\n      otherOptions = _objectWithoutProperties(options, ['key', 'onlyResolvesLast']);\n    var key = keyOptions.apply(undefined, _toConsumableArray(args));\n    // If the debounced function does not exist for this key, we create one on the fly and return it\n    if (!_this.debounceCache[key]) {\n      var debouncedFunc = debounce(func, wait, otherOptions);\n      if (onlyResolvesLastOption) {\n        debouncedFunc = onlyResolvesLast(debouncedFunc);\n      }\n      _this.debounceCache[key] = debouncedFunc;\n    }\n    return _this.debounceCache[key];\n  };\n  this.debounceCache = {};\n};\nvar DefaultOptions = {\n  // By default, the key is null, which means that all the function calls\n  // will share the same debounced function\n  // Providing a key function permit to use the call arguments\n  // and route to a distinct debounced function\n  key: function key() {\n    return null;\n  },\n  // By default, a debounced function will only resolve\n  // the last promise it returned\n  // Former calls will stay unresolved, so that you don't have\n  // to handle concurrency issues in your code\n  onlyResolvesLast: true\n};\nfunction AwesomeDebouncePromise(func, wait, options) {\n  var finalOptions = _extends({}, DefaultOptions, options);\n  var debounceCache = new DebounceCache();\n  return function AwesomeDebouncePromiseWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var debouncedFn = debounceCache.getDebouncedFunction(func, wait, finalOptions, args);\n    return debouncedFn.apply(undefined, args);\n  };\n}\nexports.default = AwesomeDebouncePromise;","map":null,"metadata":{},"sourceType":"script"}