{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { mix } from \"./mix\";\nimport conf from \"./config\";\nimport { resolver } from \"./resolver\";\nvar JSON_MIME = \"application/json\";\nvar CONTENT_TYPE_HEADER = \"Content-Type\";\nfunction extractContentType(headers) {\n  var _a;\n  if (headers === void 0) {\n    headers = {};\n  }\n  return (_a = Object.entries(headers).find(function (_a) {\n    var k = _a[0];\n    return k.toLowerCase() === CONTENT_TYPE_HEADER.toLowerCase();\n  })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isLikelyJsonMime(value) {\n  return /^application\\/.*json.*/.test(value);\n}\n/**\n * The Wretcher class used to perform easy fetch requests.\n *\n * Immutability : almost every method of this class return a fresh Wretcher object.\n */\nvar Wretcher = /** @class */function () {\n  function Wretcher(_url, _options, _catchers, _resolvers, _middlewares, _deferredChain) {\n    if (_catchers === void 0) {\n      _catchers = new Map();\n    }\n    if (_resolvers === void 0) {\n      _resolvers = [];\n    }\n    if (_middlewares === void 0) {\n      _middlewares = [];\n    }\n    if (_deferredChain === void 0) {\n      _deferredChain = [];\n    }\n    this._url = _url;\n    this._options = _options;\n    this._catchers = _catchers;\n    this._resolvers = _resolvers;\n    this._middlewares = _middlewares;\n    this._deferredChain = _deferredChain;\n  }\n  Wretcher.factory = function (url, options) {\n    if (url === void 0) {\n      url = \"\";\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    return new Wretcher(url, options);\n  };\n  Wretcher.prototype.selfFactory = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.url,\n      url = _c === void 0 ? this._url : _c,\n      _d = _b.options,\n      options = _d === void 0 ? this._options : _d,\n      _e = _b.catchers,\n      catchers = _e === void 0 ? this._catchers : _e,\n      _f = _b.resolvers,\n      resolvers = _f === void 0 ? this._resolvers : _f,\n      _g = _b.middlewares,\n      middlewares = _g === void 0 ? this._middlewares : _g,\n      _h = _b.deferredChain,\n      deferredChain = _h === void 0 ? this._deferredChain : _h;\n    return new Wretcher(url, __assign({}, options), new Map(catchers), __spreadArray([], resolvers, true), __spreadArray([], middlewares, true), __spreadArray([], deferredChain, true));\n  };\n  /**\n   * Sets the default fetch options used for every subsequent fetch call.\n   * @param options New default options\n   * @param mixin If true, mixes in instead of replacing the existing options\n   */\n  Wretcher.prototype.defaults = function (options, mixin) {\n    if (mixin === void 0) {\n      mixin = false;\n    }\n    conf.defaults = mixin ? mix(conf.defaults, options) : options;\n    return this;\n  };\n  /**\n   * Sets the method (text, json ...) used to parse the data contained in the response body in case of an HTTP error.\n   *\n   * Persists for every subsequent requests.\n   *\n   * Default is \"text\".\n   */\n  Wretcher.prototype.errorType = function (method) {\n    conf.errorType = method;\n    return this;\n  };\n  /**\n   * Sets the non-global polyfills which will be used for every subsequent calls.\n   *\n   * Needed for libraries like [fetch-ponyfill](https://github.com/qubyte/fetch-ponyfill).\n   *\n   * @param polyfills An object containing the polyfills.\n   */\n  Wretcher.prototype.polyfills = function (polyfills) {\n    conf.polyfills = __assign(__assign({}, conf.polyfills), polyfills);\n    return this;\n  };\n  /**\n   * Returns a new Wretcher object with the argument url appended and the same options.\n   * @param url String url\n   * @param replace Boolean If true, replaces the current url instead of appending\n   */\n  Wretcher.prototype.url = function (url, replace) {\n    if (replace === void 0) {\n      replace = false;\n    }\n    if (replace) return this.selfFactory({\n      url: url\n    });\n    var split = this._url.split(\"?\");\n    return this.selfFactory({\n      url: split.length > 1 ? split[0] + url + \"?\" + split[1] : this._url + url\n    });\n  };\n  /**\n   * Returns a new Wretcher object with the same url and new options.\n   * @param options New options\n   * @param mixin If true, mixes in instead of replacing the existing options\n   */\n  Wretcher.prototype.options = function (options, mixin) {\n    if (mixin === void 0) {\n      mixin = true;\n    }\n    return this.selfFactory({\n      options: mixin ? mix(this._options, options) : options\n    });\n  };\n  /**\n   * Converts a javascript object to query parameters,\n   * then appends this query string to the current url.\n   *\n   * If given a string, use the string as the query verbatim.\n   *\n   * ```\n   * let w = wretch(\"http://example.com\") // url is http://example.com\n   *\n   * // Chain query calls\n   * w = w.query({ a: 1, b : 2 }) // url is now http://example.com?a=1&b=2\n   * w = w.query(\"foo-bar-baz-woz\") // url is now http://example.com?a=1&b=2&foo-bar-baz-woz\n   *\n   * // Pass true as the second argument to replace existing query parameters\n   * w = w.query(\"c=3&d=4\", true) // url is now http://example.com?c=3&d=4\n   * ```\n   *\n   * @param qp An object which will be converted, or a string which will be used verbatim.\n   */\n  Wretcher.prototype.query = function (qp, replace) {\n    if (replace === void 0) {\n      replace = false;\n    }\n    return this.selfFactory({\n      url: appendQueryParams(this._url, qp, replace)\n    });\n  };\n  /**\n   * Set request headers.\n   * @param headerValues An object containing header keys and values\n   */\n  Wretcher.prototype.headers = function (headerValues) {\n    return this.selfFactory({\n      options: mix(this._options, {\n        headers: headerValues || {}\n      })\n    });\n  };\n  /**\n   * Shortcut to set the \"Accept\" header.\n   * @param headerValue Header value\n   */\n  Wretcher.prototype.accept = function (headerValue) {\n    return this.headers({\n      Accept: headerValue\n    });\n  };\n  /**\n   * Shortcut to set the \"Content-Type\" header.\n   * @param headerValue Header value\n   */\n  Wretcher.prototype.content = function (headerValue) {\n    var _a;\n    return this.headers((_a = {}, _a[CONTENT_TYPE_HEADER] = headerValue, _a));\n  };\n  /**\n   * Shortcut to set the \"Authorization\" header.\n   * @param headerValue Header value\n   */\n  Wretcher.prototype.auth = function (headerValue) {\n    return this.headers({\n      Authorization: headerValue\n    });\n  };\n  /**\n   * Adds a default catcher which will be called on every subsequent request error when the error code matches.\n   * @param errorId Error code or name\n   * @param catcher: The catcher method\n   */\n  Wretcher.prototype.catcher = function (errorId, catcher) {\n    var newMap = new Map(this._catchers);\n    newMap.set(errorId, catcher);\n    return this.selfFactory({\n      catchers: newMap\n    });\n  };\n  /**\n   * Associates a custom signal with the request.\n   * @param controller : An AbortController\n   */\n  Wretcher.prototype.signal = function (controller) {\n    return this.selfFactory({\n      options: __assign(__assign({}, this._options), {\n        signal: controller.signal\n      })\n    });\n  };\n  /**\n   * Program a resolver to perform response chain tasks automatically.\n   * @param doResolve : Resolver callback\n   */\n  Wretcher.prototype.resolve = function (doResolve, clear) {\n    if (clear === void 0) {\n      clear = false;\n    }\n    return this.selfFactory({\n      resolvers: clear ? [doResolve] : __spreadArray(__spreadArray([], this._resolvers, true), [doResolve], false)\n    });\n  };\n  /**\n   * Defer wretcher methods that will be chained and called just before the request is performed.\n   */\n  Wretcher.prototype.defer = function (callback, clear) {\n    if (clear === void 0) {\n      clear = false;\n    }\n    return this.selfFactory({\n      deferredChain: clear ? [callback] : __spreadArray(__spreadArray([], this._deferredChain, true), [callback], false)\n    });\n  };\n  /**\n   * Add middlewares to intercept a request before being sent.\n   */\n  Wretcher.prototype.middlewares = function (middlewares, clear) {\n    if (clear === void 0) {\n      clear = false;\n    }\n    return this.selfFactory({\n      middlewares: clear ? middlewares : __spreadArray(__spreadArray([], this._middlewares, true), middlewares, true)\n    });\n  };\n  Wretcher.prototype.method = function (method, options, body) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (body === void 0) {\n      body = null;\n    }\n    var base = this.options(__assign(__assign({}, options), {\n      method: method\n    }));\n    // \"Jsonify\" the body if it is an object and if it is likely that the content type targets json.\n    var contentType = extractContentType(base._options.headers);\n    var jsonify = typeof body === \"object\" && (!base._options.headers || !contentType || isLikelyJsonMime(contentType));\n    base = !body ? base : jsonify ? base.json(body, contentType) : base.body(body);\n    return resolver(base._deferredChain.reduce(function (acc, curr) {\n      return curr(acc, acc._url, acc._options);\n    }, base));\n  };\n  /**\n   * Performs a get request.\n   */\n  Wretcher.prototype.get = function (options) {\n    return this.method(\"GET\", options);\n  };\n  /**\n   * Performs a delete request.\n   */\n  Wretcher.prototype.delete = function (options) {\n    return this.method(\"DELETE\", options);\n  };\n  /**\n   * Performs a put request.\n   */\n  Wretcher.prototype.put = function (body, options) {\n    return this.method(\"PUT\", options, body);\n  };\n  /**\n   * Performs a post request.\n   */\n  Wretcher.prototype.post = function (body, options) {\n    return this.method(\"POST\", options, body);\n  };\n  /**\n   * Performs a patch request.\n   */\n  Wretcher.prototype.patch = function (body, options) {\n    return this.method(\"PATCH\", options, body);\n  };\n  /**\n   * Performs a head request.\n   */\n  Wretcher.prototype.head = function (options) {\n    return this.method(\"HEAD\", options);\n  };\n  /**\n   * Performs an options request\n   */\n  Wretcher.prototype.opts = function (options) {\n    return this.method(\"OPTIONS\", options);\n  };\n  /**\n   * Replay a request.\n   */\n  Wretcher.prototype.replay = function (options) {\n    return this.method(this._options.method, options);\n  };\n  /**\n   * Sets the request body with any content.\n   * @param contents The body contents\n   */\n  Wretcher.prototype.body = function (contents) {\n    return this.selfFactory({\n      options: __assign(__assign({}, this._options), {\n        body: contents\n      })\n    });\n  };\n  /**\n   * Sets the content type header, stringifies an object and sets the request body.\n   * @param jsObject An object which will be serialized into a JSON\n   * @param contentType A custom content type.\n   */\n  Wretcher.prototype.json = function (jsObject, contentType) {\n    var currentContentType = extractContentType(this._options.headers);\n    return this.content(contentType || isLikelyJsonMime(currentContentType) && currentContentType || JSON_MIME).body(JSON.stringify(jsObject));\n  };\n  /**\n   * Converts the javascript object to a FormData and sets the request body.\n   * @param formObject An object which will be converted to a FormData\n   * @param recursive If `true`, will recurse through all nested objects\n   * Can be set as an array of string to exclude specific keys.\n   * See https://github.com/elbywan/wretch/issues/68 for more details.\n   */\n  Wretcher.prototype.formData = function (formObject, recursive) {\n    if (recursive === void 0) {\n      recursive = false;\n    }\n    return this.body(convertFormData(formObject, recursive));\n  };\n  /**\n   * Converts the input to an url encoded string and sets the content-type header and body.\n   * If the input argument is already a string, skips the conversion part.\n   *\n   * @param input An object to convert into an url encoded string or an already encoded string\n   */\n  Wretcher.prototype.formUrl = function (input) {\n    return this.body(typeof input === \"string\" ? input : convertFormUrl(input)).content(\"application/x-www-form-urlencoded\");\n  };\n  return Wretcher;\n}();\nexport { Wretcher };\n// Internal helpers\nvar appendQueryParams = function appendQueryParams(url, qp, replace) {\n  var queryString;\n  if (typeof qp === \"string\") {\n    queryString = qp;\n  } else {\n    var usp = conf.polyfill(\"URLSearchParams\", {\n      instance: true\n    });\n    for (var key in qp) {\n      if (qp[key] instanceof Array) {\n        for (var _i = 0, _a = qp[key]; _i < _a.length; _i++) {\n          var val = _a[_i];\n          usp.append(key, val);\n        }\n      } else {\n        usp.append(key, qp[key]);\n      }\n    }\n    queryString = usp.toString();\n  }\n  var split = url.split(\"?\");\n  if (!queryString) return replace ? split[0] : url;\n  if (replace || split.length < 2) return split[0] + \"?\" + queryString;\n  return url + \"&\" + queryString;\n};\nfunction convertFormData(formObject, recursive, formData, ancestors) {\n  if (recursive === void 0) {\n    recursive = false;\n  }\n  if (formData === void 0) {\n    formData = conf.polyfill(\"FormData\", {\n      instance: true\n    });\n  }\n  if (ancestors === void 0) {\n    ancestors = [];\n  }\n  Object.entries(formObject).forEach(function (_a) {\n    var key = _a[0],\n      value = _a[1];\n    var formKey = ancestors.reduce(function (acc, ancestor) {\n      return acc ? \"\".concat(acc, \"[\").concat(ancestor, \"]\") : ancestor;\n    }, null);\n    formKey = formKey ? \"\".concat(formKey, \"[\").concat(key, \"]\") : key;\n    if (value instanceof Array) {\n      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n        var item = value_1[_i];\n        formData.append(formKey + \"[]\", item);\n      }\n    } else if (recursive && typeof value === \"object\" && (!(recursive instanceof Array) || !recursive.includes(key))) {\n      if (value !== null) {\n        convertFormData(value, recursive, formData, __spreadArray(__spreadArray([], ancestors, true), [key], false));\n      }\n    } else {\n      formData.append(formKey, value);\n    }\n  });\n  return formData;\n}\nfunction encodeQueryValue(key, value) {\n  return encodeURIComponent(key) + \"=\" + encodeURIComponent(typeof value === \"object\" ? JSON.stringify(value) : \"\" + value);\n}\nfunction convertFormUrl(formObject) {\n  return Object.keys(formObject).map(function (key) {\n    var value = formObject[key];\n    if (value instanceof Array) {\n      return value.map(function (v) {\n        return encodeQueryValue(key, v);\n      }).join(\"&\");\n    }\n    return encodeQueryValue(key, value);\n  }).join(\"&\");\n}","map":null,"metadata":{},"sourceType":"module"}