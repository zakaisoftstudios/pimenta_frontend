{"ast":null,"code":"import { mix } from \"./mix\";\nimport conf from \"./config\";\nimport _perfs from \"./perfs\";\nimport { middlewareHelper } from \"./middleware\";\nvar WretchErrorWrapper = /** @class */function () {\n  function WretchErrorWrapper(error) {\n    this.error = error;\n  }\n  return WretchErrorWrapper;\n}();\nexport var resolver = function resolver(wretcher) {\n  var url = wretcher._url,\n    _catchers = wretcher._catchers,\n    resolvers = wretcher._resolvers,\n    middlewares = wretcher._middlewares,\n    opts = wretcher._options;\n  var catchers = new Map(_catchers);\n  var finalOptions = mix(conf.defaults, opts);\n  var fetchController = conf.polyfill(\"AbortController\", {\n    doThrow: false,\n    instance: true\n  });\n  if (!finalOptions[\"signal\"] && fetchController) {\n    finalOptions[\"signal\"] = fetchController.signal;\n  }\n  // Request timeout\n  var timeout = {\n    ref: null,\n    clear: function clear() {\n      if (timeout.ref) {\n        clearTimeout(timeout.ref);\n        timeout.ref = null;\n      }\n    }\n  };\n  // The generated fetch request\n  var fetchRequest = middlewareHelper(middlewares)(conf.polyfill(\"fetch\"))(url, finalOptions);\n  // Throws on an http error\n  var throwingPromise = fetchRequest.catch(function (error) {\n    throw new WretchErrorWrapper(error);\n  }).then(function (response) {\n    timeout.clear();\n    if (!response.ok) {\n      if (response.type === \"opaque\") {\n        var err = new Error(\"Opaque response\");\n        err[\"status\"] = response.status;\n        err[\"response\"] = response;\n        throw err;\n      }\n      return response[conf.errorType || \"text\"]().then(function (msg) {\n        // Enhances the error object\n        var err = new Error(msg);\n        err[conf.errorType || \"text\"] = msg;\n        err[\"status\"] = response.status;\n        err[\"response\"] = response;\n        throw err;\n      });\n    }\n    return response;\n  });\n  // Wraps the Promise in order to dispatch the error to a matching catcher\n  var catchersWrapper = function catchersWrapper(promise) {\n    return promise.catch(function (err) {\n      timeout.clear();\n      var error = err instanceof WretchErrorWrapper ? err.error : err;\n      if (err instanceof WretchErrorWrapper && catchers.has(\"__fromFetch\")) return catchers.get(\"__fromFetch\")(error, wretcher);else if (catchers.has(error.status)) return catchers.get(error.status)(error, wretcher);else if (catchers.has(error.name)) return catchers.get(error.name)(error, wretcher);else throw error;\n    });\n  };\n  var bodyParser = function bodyParser(funName) {\n    return function (cb) {\n      return funName ?\n      // If a callback is provided, then callback with the body result otherwise return the parsed body itself.\n      catchersWrapper(throwingPromise.then(function (_) {\n        return _ && _[funName]();\n      }).then(function (_) {\n        return cb ? cb(_) : _;\n      })) :\n      // No body parsing method - return the response\n      catchersWrapper(throwingPromise.then(function (_) {\n        return cb ? cb(_) : _;\n      }));\n    };\n  };\n  var responseChain = {\n    /**\n     * Retrieves the raw result as a promise.\n     */\n    res: bodyParser(null),\n    /**\n     * Retrieves the result as a parsed JSON object.\n     */\n    json: bodyParser(\"json\"),\n    /**\n     * Retrieves the result as a Blob object.\n     */\n    blob: bodyParser(\"blob\"),\n    /**\n     * Retrieves the result as a FormData object.\n     */\n    formData: bodyParser(\"formData\"),\n    /**\n     * Retrieves the result as an ArrayBuffer object.\n     */\n    arrayBuffer: bodyParser(\"arrayBuffer\"),\n    /**\n     * Retrieves the result as a string.\n     */\n    text: bodyParser(\"text\"),\n    /**\n     * Performs a callback on the API performance timings of the request.\n     *\n     * Warning: Still experimental on browsers and node.js\n     */\n    perfs: function perfs(cb) {\n      fetchRequest.then(function (res) {\n        return _perfs.observe(res.url, cb);\n      }).catch(function () {});\n      return responseChain;\n    },\n    /**\n     * Aborts the request after a fixed time.\n     *\n     * @param time Time in milliseconds\n     * @param controller A custom controller\n     */\n    setTimeout: function (_setTimeout) {\n      function setTimeout(_x, _x2) {\n        return _setTimeout.apply(this, arguments);\n      }\n      setTimeout.toString = function () {\n        return _setTimeout.toString();\n      };\n      return setTimeout;\n    }(function (time, controller) {\n      if (controller === void 0) {\n        controller = fetchController;\n      }\n      timeout.clear();\n      timeout.ref = setTimeout(function () {\n        return controller.abort();\n      }, time);\n      return responseChain;\n    }),\n    /**\n     * Returns the automatically generated AbortController alongside the current wretch response as a pair.\n     */\n    controller: function controller() {\n      return [fetchController, responseChain];\n    },\n    /**\n     * Catches an http response with a specific error code or name and performs a callback.\n     */\n    error: function error(errorId, cb) {\n      catchers.set(errorId, cb);\n      return responseChain;\n    },\n    /**\n     * Catches a bad request (http code 400) and performs a callback.\n     */\n    badRequest: function badRequest(cb) {\n      return responseChain.error(400, cb);\n    },\n    /**\n     * Catches an unauthorized request (http code 401) and performs a callback.\n     */\n    unauthorized: function unauthorized(cb) {\n      return responseChain.error(401, cb);\n    },\n    /**\n     * Catches a forbidden request (http code 403) and performs a callback.\n     */\n    forbidden: function forbidden(cb) {\n      return responseChain.error(403, cb);\n    },\n    /**\n     * Catches a \"not found\" request (http code 404) and performs a callback.\n     */\n    notFound: function notFound(cb) {\n      return responseChain.error(404, cb);\n    },\n    /**\n     * Catches a timeout (http code 408) and performs a callback.\n     */\n    timeout: function timeout(cb) {\n      return responseChain.error(408, cb);\n    },\n    /**\n     * Catches an internal server error (http code 500) and performs a callback.\n     */\n    internalError: function internalError(cb) {\n      return responseChain.error(500, cb);\n    },\n    /**\n     * Catches errors thrown when calling the fetch function and performs a callback.\n     */\n    fetchError: function fetchError(cb) {\n      return responseChain.error(\"__fromFetch\", cb);\n    },\n    /**\n     * Catches an AbortError and performs a callback.\n     */\n    onAbort: function onAbort(cb) {\n      return responseChain.error(\"AbortError\", cb);\n    }\n  };\n  return resolvers.reduce(function (chain, r) {\n    return r(chain, wretcher);\n  }, responseChain);\n};","map":null,"metadata":{},"sourceType":"module"}