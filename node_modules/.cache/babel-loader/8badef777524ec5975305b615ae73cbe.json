{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"react\"), require(\"prop-types\"));else if (typeof define === 'function' && define.amd) define([\"react\", \"prop-types\"], factory);else if (typeof exports === 'object') exports[\"ReactCrop\"] = factory(require(\"react\"), require(\"prop-types\"));else root[\"ReactCrop\"] = factory(root[\"React\"], root[\"PropTypes\"]);\n})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/\n      var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __webpack_require__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) {\n          /******/return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n          /******/i: moduleId,\n          /******/l: false,\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.l = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/\n      __webpack_require__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/\n      __webpack_require__.c = installedModules;\n      /******/\n      /******/ // define getter function for harmony exports\n      /******/\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/if (!__webpack_require__.o(exports, name)) {\n          /******/Object.defineProperty(exports, name, {\n            /******/configurable: false,\n            /******/enumerable: true,\n            /******/get: getter\n            /******/\n          });\n          /******/\n        }\n        /******/\n      };\n      /******/\n      /******/ // getDefaultExport function for compatibility with non-harmony modules\n      /******/\n      __webpack_require__.n = function (module) {\n        /******/var getter = module && module.__esModule ? /******/function getDefault() {\n          return module['default'];\n        } : /******/function getModuleExports() {\n          return module;\n        };\n        /******/\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n        return getter;\n        /******/\n      };\n      /******/\n      /******/ // Object.prototype.hasOwnProperty.call\n      /******/\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n      /******/ // __webpack_public_path__\n      /******/\n      __webpack_require__.p = \"\";\n      /******/\n      /******/ // Load entry module and return exports\n      /******/\n      return __webpack_require__(__webpack_require__.s = 0);\n      /******/\n    }\n    /************************************************************************/\n    /******/([/* 0 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.containCrop = exports.makeAspectCrop = exports.getPixelCrop = exports.Component = exports.default = undefined;\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n          try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n              if (i && _arr.length === i) break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"]) _i[\"return\"]();\n            } finally {\n              if (_d) throw _e;\n            }\n          }\n          return _arr;\n        }\n        return function (arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }(); /* globals document, window */\n\n      var _react = __webpack_require__(1);\n      var _react2 = _interopRequireDefault(_react);\n      var _propTypes = __webpack_require__(2);\n      var _propTypes2 = _interopRequireDefault(_propTypes);\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n      function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      }\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      // Feature detection\n      // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners\n      var passiveSupported = false;\n      try {\n        window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n          get: function get() {\n            passiveSupported = true;\n            return true;\n          }\n        }));\n      } catch (err) {} // eslint-disable-line no-empty\n\n      var EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';\n      function getClientPos(e) {\n        var pageX = void 0;\n        var pageY = void 0;\n        if (e.touches) {\n          var _e$touches = _slicedToArray(e.touches, 1);\n          var _e$touches$ = _e$touches[0];\n          pageX = _e$touches$.pageX;\n          pageY = _e$touches$.pageY;\n        } else {\n          pageX = e.pageX;\n          pageY = e.pageY;\n        }\n        return {\n          x: pageX,\n          y: pageY\n        };\n      }\n      function clamp(num, min, max) {\n        return Math.min(Math.max(num, min), max);\n      }\n      function isCropValid(crop) {\n        return crop && crop.width && crop.height && !isNaN(crop.width) && !isNaN(crop.height);\n      }\n      function inverseOrd(ord) {\n        var inversedOrd = void 0;\n        if (ord === 'n') inversedOrd = 's';else if (ord === 'ne') inversedOrd = 'sw';else if (ord === 'e') inversedOrd = 'w';else if (ord === 'se') inversedOrd = 'nw';else if (ord === 's') inversedOrd = 'n';else if (ord === 'sw') inversedOrd = 'ne';else if (ord === 'w') inversedOrd = 'e';else if (ord === 'nw') inversedOrd = 'se';\n        return inversedOrd;\n      }\n      function makeAspectCrop(crop, imageAspect) {\n        if (isNaN(crop.aspect) || isNaN(imageAspect)) {\n          console.warn('`crop.aspect` and `imageAspect` need to be numbers in order to make an aspect crop', crop);\n          return crop;\n        }\n        var completeCrop = _extends({\n          x: 0,\n          y: 0\n        }, crop);\n        if (crop.width) {\n          completeCrop.height = crop.width / crop.aspect * imageAspect;\n        }\n        if (crop.height) {\n          completeCrop.width = (completeCrop.height || crop.height) * (crop.aspect / imageAspect);\n        }\n        if (crop.y + (completeCrop.height || crop.height) > 100) {\n          completeCrop.height = 100 - crop.y;\n          completeCrop.width = completeCrop.height * crop.aspect / imageAspect;\n        }\n        if (crop.x + (completeCrop.width || crop.width) > 100) {\n          completeCrop.width = 100 - crop.x;\n          completeCrop.height = completeCrop.width / crop.aspect * imageAspect;\n        }\n        return completeCrop;\n      }\n      function isAspectInvalid(crop, width, height) {\n        if (!crop.width && crop.height || crop.width && !crop.height) {\n          return true;\n        }\n        if (crop.width && crop.height && Math.round(height * (crop.height / 100) * crop.aspect) !== Math.round(width * (crop.width / 100))) {\n          return true;\n        }\n        return false;\n      }\n      function resolveCrop(crop, image) {\n        if (crop && crop.aspect && isAspectInvalid(crop, image.naturalWidth, image.naturalHeight)) {\n          return makeAspectCrop(crop, image.naturalWidth / image.naturalHeight);\n        }\n        return crop;\n      }\n      function getPixelCrop(image, percentCrop) {\n        var useNaturalImageDimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        if (!image || !percentCrop) {\n          return null;\n        }\n        var imageWidth = useNaturalImageDimensions ? image.naturalWidth : image.width;\n        var imageHeight = useNaturalImageDimensions ? image.naturalHeight : image.height;\n        var x = Math.round(imageWidth * (percentCrop.x / 100));\n        var y = Math.round(imageHeight * (percentCrop.y / 100));\n        var width = Math.round(imageWidth * (percentCrop.width / 100));\n        var height = Math.round(imageHeight * (percentCrop.height / 100));\n        return {\n          x: x,\n          y: y,\n          // Clamp width and height so rounding doesn't cause the crop to exceed bounds.\n          width: clamp(width, 0, imageWidth - x),\n          height: clamp(height, 0, imageHeight - y)\n        };\n      }\n      function containCrop(prevCrop, crop, imageAspect) {\n        var contained = _extends({}, crop);\n\n        // Fixes issue where crop can be dragged to the left when resizing with SW ord\n        // even though it's hit the bottom of the image.\n        if (crop.aspect && prevCrop.x > crop.x && crop.height + crop.y >= 100) {\n          contained.x = prevCrop.x;\n        }\n\n        // Don't let the crop grow on the opposite side when hitting an x image boundary.\n        var cropXAdjusted = false;\n        if (contained.x + contained.width > 100) {\n          contained.width = crop.width + (100 - (crop.x + crop.width));\n          contained.x = crop.x + (100 - (crop.x + contained.width));\n          cropXAdjusted = true;\n        } else if (contained.x < 0) {\n          contained.width = crop.x + crop.width;\n          contained.x = 0;\n          cropXAdjusted = true;\n        }\n        if (cropXAdjusted && crop.aspect) {\n          // Adjust height to the resized width to maintain aspect.\n          contained.height = contained.width / crop.aspect * imageAspect;\n          // If sizing in up direction we need to pin Y at the point it\n          // would be at the boundary.\n          if (prevCrop.y > contained.y) {\n            contained.y = crop.y + (crop.height - contained.height);\n          }\n        }\n\n        // Don't let the crop grow on the opposite side when hitting a y image boundary.\n        var cropYAdjusted = false;\n        if (contained.y + contained.height > 100) {\n          contained.height = crop.height + (100 - (crop.y + crop.height));\n          contained.y = crop.y + (100 - (crop.y + contained.height));\n          cropYAdjusted = true;\n        } else if (contained.y < 0) {\n          contained.height = crop.y + crop.height;\n          contained.y = 0;\n          cropYAdjusted = true;\n        }\n        if (cropYAdjusted && crop.aspect) {\n          // Adjust width to the resized height to maintain aspect.\n          contained.width = contained.height * crop.aspect / imageAspect;\n          // If sizing in up direction we need to pin X at the point it\n          // would be at the boundary.\n          if (contained.x < crop.x) {\n            contained.x = crop.x + (crop.width - contained.width);\n          }\n        }\n        return contained;\n      }\n      var ReactCrop = function (_PureComponent) {\n        _inherits(ReactCrop, _PureComponent);\n        function ReactCrop() {\n          var _ref;\n          var _temp, _this, _ret;\n          _classCallCheck(this, ReactCrop);\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ReactCrop.__proto__ || Object.getPrototypeOf(ReactCrop)).call.apply(_ref, [this].concat(args))), _this), _this.window = window, _this.document = document, _this.state = {}, _this.onCropMouseTouchDown = function (e) {\n            var _this$props = _this.props,\n              crop = _this$props.crop,\n              disabled = _this$props.disabled;\n            if (disabled) {\n              return;\n            }\n            e.preventDefault(); // Stop drag selection.\n\n            var clientPos = getClientPos(e);\n\n            // Focus for detecting keypress.\n            _this.componentRef.focus({\n              preventScroll: true\n            });\n            var ord = e.target.dataset.ord;\n            var xInversed = ord === 'nw' || ord === 'w' || ord === 'sw';\n            var yInversed = ord === 'nw' || ord === 'n' || ord === 'ne';\n            var cropOffset = void 0;\n            if (crop.aspect) {\n              cropOffset = _this.getElementOffset(_this.cropSelectRef);\n            }\n            _this.evData = {\n              clientStartX: clientPos.x,\n              clientStartY: clientPos.y,\n              cropStartWidth: crop.width,\n              cropStartHeight: crop.height,\n              cropStartX: xInversed ? crop.x + crop.width : crop.x,\n              cropStartY: yInversed ? crop.y + crop.height : crop.y,\n              xInversed: xInversed,\n              yInversed: yInversed,\n              xCrossOver: xInversed,\n              yCrossOver: yInversed,\n              startXCrossOver: xInversed,\n              startYCrossOver: yInversed,\n              isResize: e.target.dataset.ord,\n              ord: ord,\n              cropOffset: cropOffset\n            };\n            _this.mouseDownOnCrop = true;\n            _this.setState({\n              cropIsActive: true\n            });\n          }, _this.onComponentMouseTouchDown = function (e) {\n            var _this$props2 = _this.props,\n              crop = _this$props2.crop,\n              disabled = _this$props2.disabled,\n              locked = _this$props2.locked,\n              keepSelection = _this$props2.keepSelection,\n              onChange = _this$props2.onChange,\n              useNaturalImageDimensions = _this$props2.useNaturalImageDimensions;\n            if (e.target !== _this.imageRef) {\n              return;\n            }\n            if (disabled || locked || keepSelection && isCropValid(crop)) {\n              return;\n            }\n            e.preventDefault(); // Stop drag selection.\n\n            var clientPos = getClientPos(e);\n\n            // Focus for detecting keypress.\n            _this.componentRef.focus({\n              preventScroll: true\n            });\n            var imageOffset = _this.getElementOffset(_this.imageRef);\n            var xPc = (clientPos.x - imageOffset.left) / _this.imageRef.width * 100;\n            var yPc = (clientPos.y - imageOffset.top) / _this.imageRef.height * 100;\n            var nextCrop = {\n              aspect: crop ? crop.aspect : undefined,\n              x: xPc,\n              y: yPc,\n              width: 0,\n              height: 0\n            };\n            _this.evData = {\n              clientStartX: clientPos.x,\n              clientStartY: clientPos.y,\n              cropStartWidth: nextCrop.width,\n              cropStartHeight: nextCrop.height,\n              cropStartX: nextCrop.x,\n              cropStartY: nextCrop.y,\n              xInversed: false,\n              yInversed: false,\n              xCrossOver: false,\n              yCrossOver: false,\n              startXCrossOver: false,\n              startYCrossOver: false,\n              isResize: true,\n              ord: 'nw'\n            };\n            _this.mouseDownOnCrop = true;\n            onChange(nextCrop, getPixelCrop(_this.imageRef, nextCrop, useNaturalImageDimensions));\n            _this.setState({\n              cropIsActive: true\n            });\n          }, _this.onDocMouseTouchMove = function (e) {\n            var _this$props3 = _this.props,\n              crop = _this$props3.crop,\n              disabled = _this$props3.disabled,\n              onChange = _this$props3.onChange,\n              onDragStart = _this$props3.onDragStart;\n            if (disabled) {\n              return;\n            }\n            if (!_this.mouseDownOnCrop) {\n              return;\n            }\n            e.preventDefault(); // Stop drag selection.\n            if (!_this.dragStarted) {\n              _this.dragStarted = true;\n              onDragStart();\n            }\n            var _this2 = _this,\n              evData = _this2.evData;\n            var clientPos = getClientPos(e);\n            if (evData.isResize && crop.aspect && evData.cropOffset) {\n              clientPos.y = _this.straightenYPath(clientPos.x);\n            }\n            var xDiffPx = clientPos.x - evData.clientStartX;\n            evData.xDiffPc = xDiffPx / _this.imageRef.width * 100;\n            var yDiffPx = clientPos.y - evData.clientStartY;\n            evData.yDiffPc = yDiffPx / _this.imageRef.height * 100;\n            var nextCrop = void 0;\n            if (evData.isResize) {\n              nextCrop = _this.resizeCrop();\n            } else {\n              nextCrop = _this.dragCrop();\n            }\n            if (nextCrop !== crop) {\n              onChange(nextCrop, getPixelCrop(_this.imageRef, nextCrop));\n            }\n          }, _this.onComponentKeyDown = function (e) {\n            var _this$props4 = _this.props,\n              crop = _this$props4.crop,\n              disabled = _this$props4.disabled,\n              onChange = _this$props4.onChange,\n              onComplete = _this$props4.onComplete,\n              useNaturalImageDimensions = _this$props4.useNaturalImageDimensions;\n            if (disabled) {\n              return;\n            }\n            var keyCode = e.which;\n            var nudged = false;\n            if (!isCropValid(crop)) {\n              return;\n            }\n            var nextCrop = _this.makeNewCrop();\n            if (keyCode === ReactCrop.arrowKey.left) {\n              nextCrop.x -= ReactCrop.nudgeStep;\n              nudged = true;\n            } else if (keyCode === ReactCrop.arrowKey.right) {\n              nextCrop.x += ReactCrop.nudgeStep;\n              nudged = true;\n            } else if (keyCode === ReactCrop.arrowKey.up) {\n              nextCrop.y -= ReactCrop.nudgeStep;\n              nudged = true;\n            } else if (keyCode === ReactCrop.arrowKey.down) {\n              nextCrop.y += ReactCrop.nudgeStep;\n              nudged = true;\n            }\n            if (nudged) {\n              e.preventDefault(); // Stop drag selection.\n              nextCrop.x = clamp(nextCrop.x, 0, 100 - nextCrop.width);\n              nextCrop.y = clamp(nextCrop.y, 0, 100 - nextCrop.height);\n              onChange(nextCrop, getPixelCrop(_this.imageRef, nextCrop, useNaturalImageDimensions));\n              onComplete(nextCrop, getPixelCrop(_this.imageRef, nextCrop, useNaturalImageDimensions));\n            }\n          }, _this.onDocMouseTouchEnd = function () {\n            var _this$props5 = _this.props,\n              crop = _this$props5.crop,\n              disabled = _this$props5.disabled,\n              onComplete = _this$props5.onComplete,\n              onDragEnd = _this$props5.onDragEnd,\n              useNaturalImageDimensions = _this$props5.useNaturalImageDimensions;\n            if (disabled) {\n              return;\n            }\n            if (_this.mouseDownOnCrop) {\n              _this.mouseDownOnCrop = false;\n              _this.dragStarted = false;\n              onDragEnd();\n              onComplete(crop, getPixelCrop(_this.imageRef, crop, useNaturalImageDimensions));\n              _this.setState({\n                cropIsActive: false\n              });\n            }\n          }, _temp), _possibleConstructorReturn(_this, _ret);\n        }\n        _createClass(ReactCrop, [{\n          key: 'componentDidMount',\n          value: function componentDidMount() {\n            var options = passiveSupported ? {\n              passive: false\n            } : false;\n            this.document.addEventListener('mousemove', this.onDocMouseTouchMove, options);\n            this.document.addEventListener('touchmove', this.onDocMouseTouchMove, options);\n            this.document.addEventListener('mouseup', this.onDocMouseTouchEnd, options);\n            this.document.addEventListener('touchend', this.onDocMouseTouchEnd, options);\n            this.document.addEventListener('touchcancel', this.onDocMouseTouchEnd, options);\n            if (this.imageRef.complete || this.imageRef.readyState) {\n              if (this.imageRef.naturalWidth === 0) {\n                // Broken load on iOS, PR #51\n                // https://css-tricks.com/snippets/jquery/fixing-load-in-ie-for-cached-images/\n                // http://stackoverflow.com/questions/821516/browser-independent-way-to-detect-when-image-has-been-loaded\n                var src = this.imageRef.src;\n                this.imageRef.src = EMPTY_GIF;\n                this.imageRef.src = src;\n              } else {\n                this.onImageLoad(this.imageRef);\n              }\n            }\n          }\n        }, {\n          key: 'componentWillUnmount',\n          value: function componentWillUnmount() {\n            this.document.removeEventListener('mousemove', this.onDocMouseTouchMove);\n            this.document.removeEventListener('touchmove', this.onDocMouseTouchMove);\n            this.document.removeEventListener('mouseup', this.onDocMouseTouchEnd);\n            this.document.removeEventListener('touchend', this.onDocMouseTouchEnd);\n            this.document.removeEventListener('touchcancel', this.onDocMouseTouchEnd);\n          }\n        }, {\n          key: 'onImageLoad',\n          value: function onImageLoad(image) {\n            var _props = this.props,\n              crop = _props.crop,\n              onComplete = _props.onComplete,\n              onChange = _props.onChange,\n              onImageLoaded = _props.onImageLoaded,\n              useNaturalImageDimensions = _props.useNaturalImageDimensions;\n            var resolvedCrop = resolveCrop(crop, image);\n\n            // Return false from onImageLoaded if you set the crop with setState in there as otherwise the subsequent\n            // onChange + onComplete will not have your updated crop.\n            var res = onImageLoaded(image, getPixelCrop(image, resolvedCrop, useNaturalImageDimensions));\n            if (res !== false && resolvedCrop !== crop) {\n              onChange(resolvedCrop, getPixelCrop(image, resolvedCrop, useNaturalImageDimensions));\n              onComplete(resolvedCrop, getPixelCrop(image, resolvedCrop, useNaturalImageDimensions));\n            }\n          }\n        }, {\n          key: 'getElementOffset',\n          value: function getElementOffset(el) {\n            var rect = el.getBoundingClientRect();\n            var docEl = this.document.documentElement;\n            var rectTop = rect.top + this.window.pageYOffset - docEl.clientTop;\n            var rectLeft = rect.left + this.window.pageXOffset - docEl.clientLeft;\n            return {\n              top: rectTop,\n              left: rectLeft\n            };\n          }\n        }, {\n          key: 'getCropStyle',\n          value: function getCropStyle() {\n            var crop = this.props.crop;\n            return {\n              top: crop.y + '%',\n              left: crop.x + '%',\n              width: crop.width + '%',\n              height: crop.height + '%'\n            };\n          }\n        }, {\n          key: 'getNewSize',\n          value: function getNewSize() {\n            var _props2 = this.props,\n              crop = _props2.crop,\n              minWidth = _props2.minWidth,\n              maxWidth = _props2.maxWidth,\n              minHeight = _props2.minHeight,\n              maxHeight = _props2.maxHeight;\n            var evData = this.evData;\n            var imageAspect = this.imageRef.width / this.imageRef.height;\n\n            // New width.\n            var newWidth = evData.cropStartWidth + evData.xDiffPc;\n            if (evData.xCrossOver) {\n              newWidth = Math.abs(newWidth);\n            }\n            newWidth = clamp(newWidth, minWidth, maxWidth);\n\n            // New height.\n            var newHeight = void 0;\n            if (crop.aspect) {\n              newHeight = newWidth / crop.aspect * imageAspect;\n            } else {\n              newHeight = evData.cropStartHeight + evData.yDiffPc;\n            }\n            if (evData.yCrossOver) {\n              // Cap if polarity is inversed and the height fills the y space.\n              newHeight = Math.min(Math.abs(newHeight), evData.cropStartY);\n            }\n            newHeight = clamp(newHeight, minHeight, maxHeight);\n            if (crop.aspect) {\n              newWidth = clamp(newHeight * crop.aspect / imageAspect, 0, 100);\n            }\n            return {\n              width: newWidth,\n              height: newHeight\n            };\n          }\n        }, {\n          key: 'dragCrop',\n          value: function dragCrop() {\n            var nextCrop = this.makeNewCrop();\n            var evData = this.evData;\n            nextCrop.x = clamp(evData.cropStartX + evData.xDiffPc, 0, 100 - nextCrop.width);\n            nextCrop.y = clamp(evData.cropStartY + evData.yDiffPc, 0, 100 - nextCrop.height);\n            return nextCrop;\n          }\n        }, {\n          key: 'resizeCrop',\n          value: function resizeCrop() {\n            var nextCrop = this.makeNewCrop();\n            var evData = this.evData;\n            var _props3 = this.props,\n              crop = _props3.crop,\n              minWidth = _props3.minWidth,\n              minHeight = _props3.minHeight;\n            var ord = evData.ord;\n            var imageAspect = this.imageRef.width / this.imageRef.height;\n\n            // On the inverse change the diff so it's the same and\n            // the same algo applies.\n            if (evData.xInversed) {\n              evData.xDiffPc -= evData.cropStartWidth * 2;\n            }\n            if (evData.yInversed) {\n              evData.yDiffPc -= evData.cropStartHeight * 2;\n            }\n\n            // New size.\n            var newSize = this.getNewSize();\n\n            // Adjust x/y to give illusion of 'staticness' as width/height is increased\n            // when polarity is inversed.\n            var newX = evData.cropStartX;\n            var newY = evData.cropStartY;\n            if (evData.xCrossOver) {\n              newX = nextCrop.x + (nextCrop.width - newSize.width);\n            }\n            if (evData.yCrossOver) {\n              // This not only removes the little \"shake\" when inverting at a diagonal, but for some\n              // reason y was way off at fast speeds moving sw->ne with fixed aspect only, I couldn't\n              // figure out why.\n              if (evData.lastYCrossover === false) {\n                newY = nextCrop.y - newSize.height;\n              } else {\n                newY = nextCrop.y + (nextCrop.height - newSize.height);\n              }\n            }\n            var containedCrop = containCrop(this.props.crop, {\n              x: newX,\n              y: newY,\n              width: newSize.width,\n              height: newSize.height,\n              aspect: nextCrop.aspect\n            }, imageAspect);\n\n            // Apply x/y/width/height changes depending on ordinate (fixed aspect always applies both).\n            if (nextCrop.aspect || ReactCrop.xyOrds.indexOf(ord) > -1) {\n              nextCrop.x = containedCrop.x;\n              nextCrop.y = containedCrop.y;\n              nextCrop.width = containedCrop.width;\n              nextCrop.height = containedCrop.height;\n            } else if (ReactCrop.xOrds.indexOf(ord) > -1) {\n              nextCrop.x = containedCrop.x;\n              nextCrop.width = containedCrop.width;\n            } else if (ReactCrop.yOrds.indexOf(ord) > -1) {\n              nextCrop.y = containedCrop.y;\n              nextCrop.height = containedCrop.height;\n            }\n            evData.lastYCrossover = evData.yCrossOver;\n            this.crossOverCheck();\n\n            // Ensure new dimensions aren't less than min dimensions.\n            if (minWidth && nextCrop.width < minWidth) {\n              return crop;\n            }\n            if (minHeight && nextCrop.height < minHeight) {\n              return crop;\n            }\n            return nextCrop;\n          }\n        }, {\n          key: 'straightenYPath',\n          value: function straightenYPath(clientX) {\n            var evData = this.evData;\n            var ord = evData.ord;\n            var cropOffset = evData.cropOffset;\n            var cropStartWidth = evData.cropStartWidth / 100 * this.imageRef.width;\n            var cropStartHeight = evData.cropStartHeight / 100 * this.imageRef.height;\n            var k = void 0;\n            var d = void 0;\n            if (ord === 'nw' || ord === 'se') {\n              k = cropStartHeight / cropStartWidth;\n              d = cropOffset.top - cropOffset.left * k;\n            } else {\n              k = -cropStartHeight / cropStartWidth;\n              d = cropOffset.top + (cropStartHeight - cropOffset.left * k);\n            }\n            return k * clientX + d;\n          }\n        }, {\n          key: 'createCropSelection',\n          value: function createCropSelection() {\n            var _this3 = this;\n            var _props4 = this.props,\n              disabled = _props4.disabled,\n              locked = _props4.locked,\n              renderSelectionAddon = _props4.renderSelectionAddon;\n            var style = this.getCropStyle();\n            return _react2.default.createElement('div', {\n              ref: function ref(n) {\n                _this3.cropSelectRef = n;\n              },\n              style: style,\n              className: 'ReactCrop__crop-selection',\n              onMouseDown: this.onCropMouseTouchDown,\n              onTouchStart: this.onCropMouseTouchDown,\n              role: 'presentation'\n            }, !disabled && !locked && _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-elements'\n            }, _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-bar ord-n',\n              'data-ord': 'n'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-bar ord-e',\n              'data-ord': 'e'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-bar ord-s',\n              'data-ord': 's'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-bar ord-w',\n              'data-ord': 'w'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-nw',\n              'data-ord': 'nw'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-n',\n              'data-ord': 'n'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-ne',\n              'data-ord': 'ne'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-e',\n              'data-ord': 'e'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-se',\n              'data-ord': 'se'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-s',\n              'data-ord': 's'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-sw',\n              'data-ord': 'sw'\n            }), _react2.default.createElement('div', {\n              className: 'ReactCrop__drag-handle ord-w',\n              'data-ord': 'w'\n            })), renderSelectionAddon && renderSelectionAddon(this.state));\n          }\n        }, {\n          key: 'makeNewCrop',\n          value: function makeNewCrop() {\n            return _extends({}, ReactCrop.defaultCrop, this.props.crop);\n          }\n        }, {\n          key: 'crossOverCheck',\n          value: function crossOverCheck() {\n            var evData = this.evData;\n            if (!evData.xCrossOver && -Math.abs(evData.cropStartWidth) - evData.xDiffPc >= 0 || evData.xCrossOver && -Math.abs(evData.cropStartWidth) - evData.xDiffPc <= 0) {\n              evData.xCrossOver = !evData.xCrossOver;\n            }\n            if (!evData.yCrossOver && -Math.abs(evData.cropStartHeight) - evData.yDiffPc >= 0 || evData.yCrossOver && -Math.abs(evData.cropStartHeight) - evData.yDiffPc <= 0) {\n              evData.yCrossOver = !evData.yCrossOver;\n            }\n            var swapXOrd = evData.xCrossOver !== evData.startXCrossOver;\n            var swapYOrd = evData.yCrossOver !== evData.startYCrossOver;\n            evData.inversedXOrd = swapXOrd ? inverseOrd(evData.ord) : false;\n            evData.inversedYOrd = swapYOrd ? inverseOrd(evData.ord) : false;\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            var _this4 = this;\n            var _props5 = this.props,\n              children = _props5.children,\n              className = _props5.className,\n              crossorigin = _props5.crossorigin,\n              crop = _props5.crop,\n              disabled = _props5.disabled,\n              locked = _props5.locked,\n              imageAlt = _props5.imageAlt,\n              onImageError = _props5.onImageError,\n              src = _props5.src,\n              style = _props5.style,\n              imageStyle = _props5.imageStyle;\n            var cropIsActive = this.state.cropIsActive;\n            var cropSelection = void 0;\n            if (isCropValid(crop)) {\n              cropSelection = this.createCropSelection();\n            }\n            var componentClasses = ['ReactCrop'];\n            if (cropIsActive) {\n              componentClasses.push('ReactCrop--active');\n            }\n            if (crop) {\n              if (crop.aspect) {\n                componentClasses.push('ReactCrop--fixed-aspect');\n              }\n\n              // In this case we have to shadow the image, since the box-shadow\n              // on the crop won't work.\n              if (cropIsActive && (!crop.width || !crop.height)) {\n                componentClasses.push('ReactCrop--crop-invisible');\n              }\n            }\n            if (disabled) {\n              componentClasses.push('ReactCrop--disabled');\n            }\n            if (locked) {\n              componentClasses.push('ReactCrop--locked');\n            }\n            if (className) {\n              componentClasses.push.apply(componentClasses, _toConsumableArray(className.split(' ')));\n            }\n            return _react2.default.createElement('div', {\n              ref: function ref(n) {\n                _this4.componentRef = n;\n              },\n              className: componentClasses.join(' '),\n              style: style,\n              onTouchStart: this.onComponentMouseTouchDown,\n              onMouseDown: this.onComponentMouseTouchDown,\n              role: 'presentation',\n              tabIndex: 1,\n              onKeyDown: this.onComponentKeyDown\n            }, _react2.default.createElement('img', {\n              ref: function ref(n) {\n                _this4.imageRef = n;\n              },\n              crossOrigin: crossorigin,\n              className: 'ReactCrop__image',\n              style: imageStyle,\n              src: src,\n              onLoad: function onLoad(e) {\n                return _this4.onImageLoad(e.target);\n              },\n              onError: onImageError,\n              alt: imageAlt\n            }), children, cropSelection);\n          }\n        }]);\n        return ReactCrop;\n      }(_react.PureComponent);\n      ReactCrop.xOrds = ['e', 'w'];\n      ReactCrop.yOrds = ['n', 's'];\n      ReactCrop.xyOrds = ['nw', 'ne', 'se', 'sw'];\n      ReactCrop.arrowKey = {\n        left: 37,\n        up: 38,\n        right: 39,\n        down: 40\n      };\n      ReactCrop.nudgeStep = 0.2;\n      ReactCrop.defaultCrop = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      ReactCrop.propTypes = {\n        className: _propTypes2.default.string,\n        crossorigin: _propTypes2.default.string,\n        children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.node), _propTypes2.default.node]),\n        crop: _propTypes2.default.shape({\n          aspect: _propTypes2.default.number,\n          x: _propTypes2.default.number,\n          y: _propTypes2.default.number,\n          width: _propTypes2.default.number,\n          height: _propTypes2.default.number\n        }),\n        disabled: _propTypes2.default.bool,\n        locked: _propTypes2.default.bool,\n        imageAlt: _propTypes2.default.string,\n        imageStyle: _propTypes2.default.shape({}),\n        keepSelection: _propTypes2.default.bool,\n        minWidth: _propTypes2.default.number,\n        minHeight: _propTypes2.default.number,\n        maxWidth: _propTypes2.default.number,\n        maxHeight: _propTypes2.default.number,\n        onChange: _propTypes2.default.func.isRequired,\n        onImageError: _propTypes2.default.func,\n        onComplete: _propTypes2.default.func,\n        onImageLoaded: _propTypes2.default.func,\n        onDragStart: _propTypes2.default.func,\n        onDragEnd: _propTypes2.default.func,\n        src: _propTypes2.default.string.isRequired,\n        style: _propTypes2.default.shape({}),\n        renderSelectionAddon: _propTypes2.default.func\n      };\n      ReactCrop.defaultProps = {\n        className: undefined,\n        crop: undefined,\n        crossorigin: undefined,\n        disabled: false,\n        locked: false,\n        imageAlt: '',\n        maxWidth: 100,\n        maxHeight: 100,\n        minWidth: 0,\n        minHeight: 0,\n        keepSelection: false,\n        onComplete: function onComplete() {},\n        onImageError: function onImageError() {},\n        onImageLoaded: function onImageLoaded() {},\n        onDragStart: function onDragStart() {},\n        onDragEnd: function onDragEnd() {},\n        children: undefined,\n        style: undefined,\n        imageStyle: undefined,\n        renderSelectionAddon: undefined,\n        useNaturalImageDimensions: true\n      };\n      exports.default = ReactCrop;\n      exports.Component = ReactCrop;\n      exports.getPixelCrop = getPixelCrop;\n      exports.makeAspectCrop = makeAspectCrop;\n      exports.containCrop = containCrop;\n\n      /***/\n    }, /* 1 */\n    /***/function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n      /***/\n    }, /* 2 */\n    /***/function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n      /***/\n    }\n    /******/])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}