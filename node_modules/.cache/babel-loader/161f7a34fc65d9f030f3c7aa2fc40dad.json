{"ast":null,"code":"var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar String = require('./String');\nvar Function = require('./Function');\nvar isBoolean = require('./isBoolean');\nvar isObject = require('./isObject');\nvar isNil = require('./isNil');\nvar create = require('./create');\nvar getTypeName = require('./getTypeName');\nvar dict = require('./dict');\nvar getDefaultInterfaceName = require('./getDefaultInterfaceName');\nvar isIdentity = require('./isIdentity');\nvar is = require('./is');\nvar extend = require('./extend');\nvar assign = require('./assign');\nfunction extendInterface(mixins, name) {\n  return extend(inter, mixins, name);\n}\nfunction getOptions(options) {\n  if (!isObject(options)) {\n    options = isNil(options) ? {} : {\n      name: options\n    };\n  }\n  if (!options.hasOwnProperty('strict')) {\n    options.strict = inter.strict;\n  }\n  return options;\n}\nfunction inter(props, options) {\n  options = getOptions(options);\n  var name = options.name;\n  var strict = options.strict;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(dict(String, Function).is(props), function () {\n      return 'Invalid argument props ' + assert.stringify(props) + ' supplied to interface(props, [options]) combinator (expected a dictionary String -> Type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props, [options]) combinator (expected a string)';\n    });\n    assert(isBoolean(strict), function () {\n      return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)';\n    });\n  }\n  var displayName = name || getDefaultInterfaceName(props);\n  var identity = Object.keys(props).map(function (prop) {\n    return props[prop];\n  }).every(isIdentity);\n  function Interface(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(!isNil(value), function () {\n        return 'Invalid value ' + value + ' supplied to ' + path.join('/');\n      });\n      // strictness\n      if (strict) {\n        for (var k in value) {\n          assert(props.hasOwnProperty(k), function () {\n            return 'Invalid additional prop \"' + k + '\" supplied to ' + path.join('/');\n          });\n        }\n      }\n    }\n    var idempotent = true;\n    var ret = identity ? {} : assign({}, value);\n    for (var prop in props) {\n      var expected = props[prop];\n      var actual = value[prop];\n      var instance = create(expected, actual, process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected)) : null);\n      idempotent = idempotent && actual === instance;\n      ret[prop] = instance;\n    }\n    if (idempotent) {\n      // implements idempotency\n      ret = value;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n    return ret;\n  }\n  Interface.meta = {\n    kind: 'interface',\n    props: props,\n    name: name,\n    identity: identity,\n    strict: strict\n  };\n  Interface.displayName = displayName;\n  Interface.is = function (x) {\n    if (isNil(x)) {\n      return false;\n    }\n    if (strict) {\n      for (var k in x) {\n        if (!props.hasOwnProperty(k)) {\n          return false;\n        }\n      }\n    }\n    for (var prop in props) {\n      if (!is(x[prop], props[prop])) {\n        return false;\n      }\n    }\n    return true;\n  };\n  Interface.update = function (instance, patch) {\n    return Interface(assert.update(instance, patch));\n  };\n  Interface.extend = function (xs, name) {\n    return extendInterface([Interface].concat(xs), name);\n  };\n  return Interface;\n}\ninter.strict = false;\ninter.getOptions = getOptions;\ninter.getDefaultName = getDefaultInterfaceName;\ninter.extend = extendInterface;\nmodule.exports = inter;","map":null,"metadata":{},"sourceType":"script"}