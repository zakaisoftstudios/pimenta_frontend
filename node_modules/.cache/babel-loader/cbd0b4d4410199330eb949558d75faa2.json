{"ast":null,"code":"\"use strict\";\n\nfunction argumentsToArray(args) {\n  return Array.prototype.slice.apply(args);\n}\nfunction looksLikePromise(thing) {\n  return thing && thing.then && typeof thing.then === \"function\" && typeof thing.catch === \"function\";\n}\nfunction SynchronousPromise(ctorFunction) {\n  this.status = \"pending\";\n  this._paused = false;\n  this._next = [];\n  this._data = [];\n  this._runConstructorFunction(ctorFunction);\n}\nSynchronousPromise.prototype = {\n  then: function then(next, fail) {\n    this._next.push([next, fail]);\n    if (this._isPendingResolutionOrRejection()) {\n      return this;\n    }\n    return this._applyNext();\n  },\n  catch: function _catch(fn) {\n    this._next.push([undefined, fn]);\n    if (this._isPendingResolutionOrRejection()) {\n      return this;\n    }\n    return this._applyNext();\n  },\n  pause: function pause() {\n    this._paused = true;\n    return this;\n  },\n  resume: function resume() {\n    this._paused = false;\n    return this._applyNext();\n  },\n  _runConstructorFunction: function _runConstructorFunction(ctorFunction) {\n    var self = this;\n    this._next.push([function (r) {\n      return r;\n    }, function (err) {\n      throw err;\n    }]);\n    var isRun = false;\n    ctorFunction(function (result) {\n      if (isRun) {\n        return;\n      }\n      isRun = true;\n      self._setResolved();\n      self._data = [result];\n      self._applyNext();\n    }, function (err) {\n      if (isRun) {\n        return;\n      }\n      isRun = true;\n      self._setRejected();\n      self._data = [err];\n      self._applyNext();\n    });\n  },\n  _setRejected: function _setRejected() {\n    this.status = \"rejected\";\n  },\n  _setResolved: function _setResolved() {\n    this.status = \"resolved\";\n  },\n  _setPending: function _setPending() {\n    this.status = \"pending\";\n  },\n  _applyNext: function _applyNext() {\n    if (this._next.length === 0 || this._paused) {\n      return this;\n    }\n    var next = this._findNext();\n    if (!next) {\n      return this;\n    }\n    return this._applyNextHandler(next);\n  },\n  _applyNextHandler: function _applyNextHandler(handler) {\n    try {\n      var data = handler.apply(null, this._data);\n      if (looksLikePromise(data)) {\n        this._handleNestedPromise(data);\n        return this;\n      }\n      this._setResolved();\n      this._data = [data];\n      return this._applyNext();\n    } catch (e) {\n      this._setRejected();\n      this._data = [e];\n      return this._applyNext();\n    }\n  },\n  _findNext: function _findNext() {\n    if (this._isPendingResolutionOrRejection()) {\n      return undefined;\n    }\n    var handler = this.status === \"resolved\" ? this._findFirstResolutionHandler : this._findFirstRejectionHandler;\n    return handler ? handler.apply(this) : undefined;\n  },\n  _handleNestedPromise: function _handleNestedPromise(promise) {\n    this._setPending();\n    var self = this;\n    promise.then(function (d) {\n      self._setResolved();\n      self._data = [d];\n      self._applyNext();\n    }).catch(function (e) {\n      self._setRejected();\n      self._data = [e];\n      self._applyNext();\n    });\n  },\n  _isPendingResolutionOrRejection: function _isPendingResolutionOrRejection() {\n    return this.status === \"pending\";\n  },\n  _findFirstResolutionHandler: function _findFirstResolutionHandler() {\n    var next;\n    while (!next && this._next.length > 0) {\n      next = this._next.shift()[0];\n    }\n    return next;\n  },\n  _findFirstRejectionHandler: function _findFirstRejectionHandler() {\n    var next;\n    while (!next && this._next.length > 0) {\n      next = this._next.shift()[1];\n    }\n    return next;\n  }\n};\nSynchronousPromise.resolve = function (data) {\n  if (looksLikePromise(data)) {\n    return data;\n  }\n  return new SynchronousPromise(function (resolve) {\n    resolve(data);\n  });\n};\nSynchronousPromise.reject = function (error) {\n  if (looksLikePromise(error)) {\n    return error;\n  }\n  return new SynchronousPromise(function (resolve, reject) {\n    reject(error);\n  });\n};\nSynchronousPromise.all = function () {\n  var args = argumentsToArray(arguments);\n  if (Array.isArray(args[0])) {\n    args = args[0];\n  }\n  if (!args.length) {\n    return SynchronousPromise.resolve([]);\n  }\n  return new SynchronousPromise(function (resolve, reject) {\n    var allData = [],\n      numResolved = 0,\n      doResolve = function doResolve() {\n        if (numResolved === args.length) {\n          resolve(allData);\n        }\n      },\n      rejected = false,\n      doReject = function doReject(err) {\n        if (rejected) {\n          return;\n        }\n        rejected = true;\n        reject(err);\n      };\n    args.forEach(function (arg, idx) {\n      SynchronousPromise.resolve(arg).then(function (thisResult) {\n        allData[idx] = thisResult;\n        numResolved += 1;\n        doResolve();\n      }).catch(function (err) {\n        doReject(err);\n      });\n    });\n  });\n};\nSynchronousPromise.unresolved = function () {\n  var stash = {};\n  var result = new SynchronousPromise(function (resolve, reject) {\n    stash.resolve = resolve;\n    stash.reject = reject;\n  });\n  result.resolve = stash.resolve;\n  result.reject = stash.reject;\n  return result;\n};\nmodule.exports = {\n  SynchronousPromise: SynchronousPromise\n};","map":null,"metadata":{},"sourceType":"script"}