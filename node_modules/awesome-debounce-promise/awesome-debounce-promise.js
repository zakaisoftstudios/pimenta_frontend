'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebounceCache = exports.onlyResolvesLast = exports.debounce = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _debouncePromise = require('debounce-promise');

var _debouncePromise2 = _interopRequireDefault(_debouncePromise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// We use DebouncePromise as a dependency as it does a great low-level job
// The behavior of the lib is to return the same promise for all function calls
var debounce = exports.debounce = function debounce(func, wait, options) {
  return (0, _debouncePromise2.default)(func, wait, options);
};

// Given a function returning promises, wrap it so that only the promise returned from last call will actually resolve
// This is useful to ignore former async results and handle concurrency issues
var onlyResolvesLast = exports.onlyResolvesLast = function onlyResolvesLast(asyncFunction) {
  // Inspired from https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html
  var makeCancelable = function makeCancelable(promise) {
    var hasCanceled_ = false;
    var wrappedPromise = new Promise(function (resolve, reject) {
      promise.then(function (val) {
        return hasCanceled_ ? undefined : resolve(val);
      }, function (error) {
        return hasCanceled_ ? undefined : reject(error);
      });
    });
    return {
      promise: wrappedPromise,
      cancel: function cancel() {
        hasCanceled_ = true;
      }
    };
  };

  var cancelPrevious = void 0;
  return function () {
    cancelPrevious && cancelPrevious();

    var _makeCancelable = makeCancelable(asyncFunction.apply(undefined, arguments)),
        promise = _makeCancelable.promise,
        cancel = _makeCancelable.cancel;

    cancelPrevious = cancel;
    return promise;
  };
};

// We create a debouncing function cache, because when wrapping the original function,
// we may actually want to route the function call to different debounced functions depending function paameters

var DebounceCache = exports.DebounceCache = function DebounceCache() {
  var _this = this;

  _classCallCheck(this, DebounceCache);

  this.getDebouncedFunction = function (func, wait, options, args) {
    var keyOptions = options.key,
        onlyResolvesLastOption = options.onlyResolvesLast,
        otherOptions = _objectWithoutProperties(options, ['key', 'onlyResolvesLast']);

    var key = keyOptions.apply(undefined, _toConsumableArray(args));
    // If the debounced function does not exist for this key, we create one on the fly and return it
    if (!_this.debounceCache[key]) {
      var debouncedFunc = debounce(func, wait, otherOptions);
      if (onlyResolvesLastOption) {
        debouncedFunc = onlyResolvesLast(debouncedFunc);
      }
      _this.debounceCache[key] = debouncedFunc;
    }
    return _this.debounceCache[key];
  };

  this.debounceCache = {};
};

var DefaultOptions = {
  // By default, the key is null, which means that all the function calls
  // will share the same debounced function
  // Providing a key function permit to use the call arguments
  // and route to a distinct debounced function
  key: function key() {
    return null;
  },

  // By default, a debounced function will only resolve
  // the last promise it returned
  // Former calls will stay unresolved, so that you don't have
  // to handle concurrency issues in your code
  onlyResolvesLast: true
};

function AwesomeDebouncePromise(func, wait, options) {
  var finalOptions = _extends({}, DefaultOptions, options);
  var debounceCache = new DebounceCache();
  return function AwesomeDebouncePromiseWrapper() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var debouncedFn = debounceCache.getDebouncedFunction(func, wait, finalOptions, args);
    return debouncedFn.apply(undefined, args);
  };
}

exports.default = AwesomeDebouncePromise;
